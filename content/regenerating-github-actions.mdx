---
title: 'Self-Regenerating GitHub Actions'
publishedAt: '2023-06-08'
summary: 'Learn how to keep your forked repository up-to-date automatically using GitHub Actions.'
---

<Image
  alt={`Screenshot of new workflow page in GitHub actions`}
  src={`/images/blog/github-actions-logo.png`}
  width={500}
  height={500}
  className="mx-auto"
  priority
/>

<br />

Forking is a standard practice in open-source development. It allows you to make changes to a repository without affecting the original repository. 

**However**, if the original repository is updated, your fork will not be updated automatically. You will have to manually pull the changes from the original repository. This can be tedious, especially if you have changes that need to be made on top of the changes from the original repository. 

In this article, we will learn how to keep your forked repository up-to-date automatically using GitHub Actions.

## My Use Case

In a project I'm working on, I brought in an anime provider repository: [consumet.ts](https://github.com/consumet/consumet.ts). As soon as I started to use the library, I found an issue that was coming from a part of the library that I had no interest in. 

I thought about how to approach the issue and decided to fork the repository and make the changes I needed. None of my changes are useful to others, so I have no intention on making a pull request to the original repo.

### The Issue Of Staying Up-To-Date

The library is well-maintained and sees commits daily at times. I needed something that would either run on a schedule or react to commits on the target repository. I took a look around for solutions but figured that this was probably easily doable with GitHub actions. The answer is yes, it is.

## Our Example

We'll be using the [TransformerOptimus/SuperAGI](https://github.com/TransformerOptimus/SuperAGI) repo as an example. As of the time of writing this; it currently does not have any actions, and is updated regularly. So it's a good candidate for this example.

## Step 0: Prerequisites

Depending on what you have the action doing, you will need various permissions. In my case, I needed to be able to push to the repository, so I needed a personal access token ([PAT](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens)) and to boost the permissions of workflows a bit.

1. Head over to your [GitHub Tokens Page](https://github.com/settings/tokens) and generate a token if you don't have one already. You only need to add the `workflows` scope. I went with a "classic" token.

2. Next, head to the **Actions** > **General** tab in the settings for the repo. Give the workflows **Read and write permissions**.

<Image
  alt={`Screenshot of workflow permissions section in GitHub settings`}
  src={`/images/blog/github-workflow-permissions.png`}
  width={650}
  height={400}
  className="mx-auto"
/>

## Step 1: Fork the Repository

Fork the repository you want to keep synchronized. You can do this by clicking the "Fork" button on the top right corner of the repository page or by adding `/fork` to the end of the repository URL.

## Step 2: Add a Secret and Increase Workflow Permissions

Next, you need to add a secret to your forked repository. This secret will be used to authenticate the GitHub Action.

To add a secret, go to the settings of the repository: **Settings** > **Security** > **Secrets and Variables** > **Actions**.

Add a new repository secret with the name `token` or `TOKEN`. This value will be picked up automatically by the workflow. Use your token as the value.

<Image
  alt={`Screenshot of secret adding section in GitHub settings`}
  src={`/images/blog/github-secrets.png`}
  width={650}
  height={500}
  className="mx-auto"
/>

## Step 3: Put Together the Action

The file name of the action must match these two lines in the script.

<Caption className="w-auto" value="I'm going with `egg` becaue it reminds me of a phoenix">
```yml title="egg.yml"
workflow_content=$(cat .github/workflows/egg.yml)
echo "$workflow_content" > .github/workflows/egg.yml
```
</Caption>


"Regenerating" the workflow is done by saving the contents to a variable, resetting the repo to the upstream, and then writing the contents back to the file. After that, your repo should match the upstream repo.

Following that, you can do whatever you need to do. In this example, we're creating an `example.txt` file.

We add the changes, commit them, and push them to the repo. If there are no changes, we don't push anything.*

<Box>
<Callout emoji='ðŸ§¨'>Read below for gotchas related to `git push`</Callout>
</Box>

This workflow automatically keeps up-to-date and adds `example.txt` to every new commit in [TransformerOptimus/SuperAGI](https://github.com/TransformerOptimus/SuperAGI). It attempts this every day at midnight.

```yml {5,24,29} title="egg.yml"
name: Regenerate

on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:
    branches: [main]

jobs:
  regenerate:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v3

    - name: Configure Git
      run: |
        git config user.name 'GITHUB_USERNAME'
        git config user.email 'GITHUB_EMAIL'

    - name: Reset origin repository to upstream
      run: |
        workflow_content=$(cat .github/workflows/egg.yml)
        git remote add upstream https://github.com/TransformerOptimus/SuperAGI
        git fetch upstream
        git reset --hard upstream/main
        git pull upstream main
        mkdir -p .github/workflows
        echo "$workflow_content" > .github/workflows/egg.yml

    - name: Custom work to be done
      run: |
        echo "Example file contents" > example.txt

    - name: Commit and push changes if there are any
      run: |
        git add -A
        git diff-index --quiet HEAD || git commit -m "chore: pull changes and redo work"
        git push origin || echo "No changes to commit"
```

<Box>
<Callout>Be sure to update the github `user.name` and `user.email`</Callout>
</Box>

The workflow can be triggered in two ways: manually by clicking the "Run workflow" button in the Actions tab of the repo, or by the cron job that is set up in the workflow. This cron job is set to run at midnight every day.

## Step 4: Add the GitHub Action

### The Preffered Way
The **BEST** way to do this is to use a method that lets you commit multiple files. I went with the [GitHub CLI](https://cli.github.com/).

This can be accomplished by cloning the forked repository and then creating a new file in the `.github/workflows` directory. After that, make all of your changes and then `commit`

```bash
gh repo clone YOUR_USERNAME/YOUR_REPO
cd YOUR_REPO
mkdir -p .github/workflows
touch .github/workflows/egg.yml
```

This is the part where you make your changes. I copy each line of the workflow into the command line to ensure that they're being applied in the same order as the workflow. Then I commit the changes of the workflow using the same command as the workflow. Your commit message does not matter because it will be overwritten by the workflow.

```bash
git add -A
git commit -m "chore: add GitHub action and changes"
git push origin
```

### The Easy Way

The easiest way to get this going is to simply add the workflow to the repo using the UI. 

This method has the advantage of not needing the command line, but if you go this route; you will have to use `git push origin -f` unless you can get the file in at the same time as your changes. That might be possible without cloning, but I don't know how to do that.

<Caption value="This method has some nasty side-effects. See below.">
<Image
  alt={`Screenshot of new workflow page in GitHub actions`}
  src={`/images/blog/github-new-workflow.png`}
  width={650}
  height={500}
  className="mx-auto"
/>
</Caption>

That's it! Your fork will now stay synchronized with the original repository automatically.

### The Downside to the Easy Way

The [preffered method](#the-preffered-method) will **NOT** push to the repository if there are ultimately no changes. 

If you use the [easy way](#the-easy-way), **you will have to force push the changes**. This is because the easy way will add the workflow to the repo, but it will not add the changes to the repo. This causes it to push to the repo every time the workflow runs. This is wasteful and should be avoided if possible.

Either way will work, but the preffered method is the best way to go. Both will run on a schedule and both will keep your fork up-to-date.

<GIF alt="Simpsons 'perfection' gif'" width={350} src="https://media.giphy.com/media/3o8doT9BL7dgtolp7O/giphy.gif"/>

## Pros and Cons

There is some setup involved, but there is no maintenance. You may have security constraints that don't allow you to use this method.

<ProsCard title="this GitHub action" pros={["You like 'Set it and forget it'", "You hate wondering if your modified dependencies are up-to-date", "You need to make modifications to a repo that is updated often"]} />

<ConsCard title="this GitHub action" cons={["You hate 'Set it and forget it' ðŸ˜±", "You have concerns about the security of storing a workflow in a variable", "You cannot automate the change you need to make"]} />

The `run` commands here are doing a **lot** of heavy lifting. This is one of those moments where I immediately wonder if the code could be better. I'm sure it could be. But this solves the problem I had, and I'm happy with it.

There are alternative ways of doing this. Notably, if you have access to the upstream repo, you can have your repo "build" immediately after the upstream repo has updated. That would be ideal, but this is reality.

I would also suggest dividing the workflow into multiple workflows. Specifically, separating the "regenerate" part from the "custom work" part.

## Recap

That's a whole lot of information. Let's recap the two methods of adding the workflow to the repo.

1. [Fork the repo](#step-1-fork-the-repository)
2. [Add your token and give write permission to actions](#step-2-add-a-secret-and-increase-workflow-permissions)
3. Clone the forked repo
4. [Add the workflow to `.github/workflows`](#the-preffered-way)
5. Make your changes
6. Commit and push the changes

OR

1. [Fork the repo](#step-1-fork-the-repository)
2. [Add your token and give write permission to actions](#step-2-add-a-secret-and-increase-workflow-permissions)
3. [Add the workflow to the repo using the UI (use `git push origin -f` in the workflow)](#the-easy-way)

## Conclusion

This is a great way to keep a forked repository up-to-date. It ensures that your fork will only be 1 commit ahead of the original repository. It's not perfect, but it works and has no maintenance. I hope this helps you automate your workflow so that you can focus on the important things.

# Additional Resources
- [GitHub Actions docs](https://docs.github.com/en/actions)
- [GitHub Actions triggers](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows)
- [Workflow syntax](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions)
- [Live example](https://github.com/plasmadice/SuperAGI)